#!/bin/zsh

# track loaded files
# local thispath="${(%):-%x}"
zsh_files+=("zsh_functions")

# Source file if exists
function sourceif() {
    [[ $# -eq 0 ]] && echo "Usage: sourceif <file> [error message]" && return 1
    if [[ $# -eq 1 ]]; then
        script="${redi}sourceif error${reset}"
    else
        script="${redi}sourceif error${reset} in ${yellow}$2${reset}"
    fi

    if [[ -f $1 ]]; then
        source $1
    else
        [[ $# -ge 2 ]] && printf "$1 not found\n" || printf "$2: $1 not found\n"
        printf "$script: ${cyan}$1${reset} not found\n"
        return 1
    fi
}

# Execute external script
function extscript() {
    /bin/bash -c "$(curl -fsSL $1)"
}

# Source external file
function extsource() {
    source /dev/stdin <<< "$(curl -fsSL $1)"
}

# Better ln command for creating symbolic links
function lns() {
    
    # function properties
    local fname="lns"
    local fargs="<destination> <source>"
    local finfo="$fname info:"
    local ferror="$fname error:"
    local fusage=$(usage $fname $fargs)
    local minargs=2
    local maxargs=2
    
    # argument check
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && log::error $ferror $args && log::info $fusage && return 1

    #main
    local dst="$1"
    local src="$2"
    local dst_c="${cyan}$dst${reset}"
    local src_c="${cyan}$src${reset}"
    local src_dir="$(dirname "$src")"
    local src_dir_c="${cyan}$src_dir${reset}"
    local arr="${yellowi}â†’${reset}"
    local errors=0

    # Check if both the destination and source are provided as absolute paths.
    if [[ "$dst" != /* ]]; then
        printf "${error} the destination $dst_c must be an absolute path.\n"
        ((errors+=1))
    fi
    if [[ "$src" != /* ]]; then
        printf "${error} the source $src_c must be an absolute path.\n"
        ((errors+=1))
    fi

    # Check if the destination is different from the source
    if [[ "$dst" == "$src" ]]; then
        printf "${error} destination and source cannot be the same.\n"
        ((errors+=1))
    fi

    # Check if the destination exists
    if [[ ! -e "$dst" ]]; then
        printf "${error} destination $dst_c does not exist.\n"
        ((errors+=1))
    fi

    # Check if the destination is readable
    if [[ ! -r "$dst" ]]; then
        printf "${error} destination $dst_c is not readable.\n"
        ((errors+=1))
    fi

    # Check if the destination is a folder or file
    if [[ ! -d "$dst" ]] && [[ ! -f "$dst" ]]; then
        printf "${error} destination $dst_c is neither a directory nor a file.\n"
        ((errors+=1))
    fi

    # Check if the current process can write to the source's folder
    if [[ ! -w "$src_dir" ]]; then
        printf "${error} cannot write to the source's folder $src_dir_c\n"
        ((errors+=1))
    fi

    # Exit if there are errors
    if [[ $errors > 0 ]]; then
        return 1
    fi
    
    # Check if exactly such a symbolic link does not already exist
    if [[ -L "$src" ]] && [[ "$(readlink "$src")" == "$dst" ]]; then
        printf "${info} symbolic link $src_c $arr $dst_c already exists.\n"
        return 0
    fi

    # Remove the existing source (file, folder, or wrong symbolic link)
    if [[ -e "$src" ]]; then
        rm -rf "$src"
        if [[ $? -ne 0 ]]; then
            printf "${error} failed while rmoving $src_c (error rissed by rm).\n"
            return 1
        else
             printf "${info} removed existing source $src_c.\n"
        fi
    fi

    # Create the symbolic link
    ln -s "$dst" "$src"
    if [[ $? != 0 ]]; then
        printf "${error} failed to create symbolic link (error rissed by ln).\n"
        return 1
    else
        printf "${info} created symbolic link: $src_c $arr $dst_c\n"
        return 0
    fi

}

# Create dir and enter it
function mdcd() {
    mkdir -p $1 && cd $_
}

# modify /etc/needrestart/needrestart.conf
# use: needrestart-mod parameter value
if [[ "$(osname)" != "macos" ]]; then
    function needrestart-mod() {
        filename=/etc/needrestart/needrestart.conf
        sudo sed -i "s/^#\?\s\?\$nrconf{$1}.*/\$nrconf{$1} = $2;/" $filename
    }
    function needrestart-quiet() {
        needrestart-mod verbosity 0
        needrestart-mod systemctl_combine 0
        needrestart-mod kernelhints 0
        needrestart-mod ucodehints 0
    }
    function needrestart-verbose() {
        needrestart-mod verbosity 1
        needrestart-mod systemctl_combine 1
        needrestart-mod kernelhints 1
        needrestart-mod ucodehints 1
    }
fi

# Search man with fzf
function fman() {
    man -k . | fzf -q "$1" --prompt='man> '  --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ", $2} {print $1}\' | xargs -r man | col -bx | bat -l man -p --color always' | tr -d '()' | awk '{printf "%s ", $2} {print $1}' | xargs -r man
}

# Extract version number from string
function getver() {
    local verstr=$1
    verstr=$(echo "$verstr" | sed 's/^[^0-9]*//')
    verstr=$(echo "$verstr" | grep -oE '[0-9]+(\.[0-9]+)*' | head -1)
    echo "$verstr"
}

# Check number of parameters
function checkargs() {
    if [[ $# -ne 3 ]]; then
        printf "${redi}checkargs error${reset}: not enough arguments (expected 3, given $#)\n"
        printf "checkargs usage: ${yellow}checkargs${reset} ${green}<min> <max> <actual>${reset}\n"
        return 1
    fi

    local min=$1
    local max=$2
    local given=$3
    local msg1=""; local msg2=""

    if [[ $min -gt $max ]]; then
        echo "checkargs: min number of arguments cannot be greater than max"
        return 1
    elif [[ $given -lt 0 ]]; then
        echo "checkargs: actual number of arguments cannot be negative"
        return 1
    fi

    if [[ $given -eq 0 ]]; then
        msg1="no arguments given"
    elif [[ $given -lt $min ]]; then
        msg1="not enough arguments"
    elif [[ $given -gt $max ]]; then
        msg1="too many arguments"
    fi

    if [[ $given -lt $min || $given -gt $max ]]; then
        if [[ $1 == $2 ]]; then
            msg2="expected $min"
        else
            msg2="expected $min to $max"
        fi
        echo "$msg1 ($msg2, given $given)"
        return 1
    fi

    echo "ok"
    return 0
}

# Usage message for functions
function usage() {
    local fname=$1
    local fargs=$2
    printf "$1 usage: ${yellow}$1${reset} ${green}$2${reset}\n"
}

# Universal better type command for bash and zsh
# returns: 'file', 'alias', 'function', 'keyword', 'builtin' or 'not found'
function utype() {
    # function properties
    local fargs="<command>"
    local minargs=0
    local maxargs=1
    # argument check
    local thisf="${funcstack[1]}"
    local error="${redi}$thisf error:${reset}"
    local usage=$(usage $thisf $fargs)
    [[ $# -eq 0 ]] && printf "$usage\n" && return 1
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && printf "$error $args\n$usage\n" && return 1

    if [[ $(shellname) == 'bash' ]]; then
        output=$(type -t $1)
        if [[ -z $output ]]; then
            echo "not found"
            return 1
        fi
    elif [[ $(shellname) == 'zsh' ]]; then
        tp=$(type $1)
        if [[ $(echo $tp | \grep -o 'not found') ]]; then
            echo "not found"
            return 1
        elif [[ $(echo $tp | \grep -o 'is /') ]]; then
            output='file'
        elif [[ $(echo $tp | \grep -o 'alias') ]]; then
            output='alias'
        elif [[ $(echo $tp | \grep -o 'shell function') ]]; then
            output='function'
        elif [[ $(echo $tp | \grep -o 'reserved') ]]; then
            output='keyword'
        elif [[ $(echo $tp | \grep -o 'builtin') ]]; then
            output='builtin'
        fi
    else
        echo "utype: unsupported shell"
        return 1
    fi

    echo $output
}

# Universal better which command for bash and zsh
function uwhich() {
    # function properties
    local fargs="<command>"
    local minargs=0
    local maxargs=1
    # argument check
    local thisf="${funcstack[1]}"
    local error="${redi}$thisf error:${reset}"
    local usage=$(usage $thisf $fargs)
    [[ $# -eq 0 ]] && printf "$usage\n" && return 1
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && printf "$error $args\n$usage\n" && return 1

    local type=$(utype $1)
    if [[ $type == "file" ]]; then
        echo $(which $1)
    elif [[ $type == "alias" ]]; then
        if [[ $(shellname) = "zsh" ]]; then
            echo $(whence -p $1)
        else
            echo $(which $1)
        fi
    elif [[ $type == "not found" ]]; then
        echo "${yellow}$1${reset} $type"
        return 1
    else
        echo "${yellow}$1${reset} is a ${green}$type${reset}"
        return 1
    fi
}

# Download and unzip file from URL
function dlunzip() {
    if [ $# -ne 2 ]; then
        echo "dlunzip (download and extract)"
        echo "Usage: dlunzip <url> <folder>"
        return 1
    fi

    url="$1"
    folder="$2"

    [[ ! $folder == /* ]] && folder="$(pwd)/$folder"
    [[ -z "$TEMP" ]] && tempdir="$HOME/.temp" || tempdir="$DLDIR"
    filename=$(basename "$url")
    tempfile="$tempdir/$filename"
    extdir="${folder}/$(basename $filename .zip)"

    mkdir -p "$folder"
    mkdir -p "$tempdir" && cd $_

    wget -q $url
    if [ $? -ne 0 ]; then
        echo "Failed to download $url"
        return 1
    fi

    unzip -q $tempfile -d $folder
    if [ $? -ne 0 ]; then
        echo "Failed to extract $tempfile to $folder"
        return 1
    fi

    rm $tempfile

    echo $extdir
}

# Calculate uptime in hours
function uptimeh() {
    if [[ $(osname) == "macos" ]]; then
        boot_timestamp=$(sysctl -n kern.boottime | awk '{print $4}' | tr -d ',')
        current_timestamp=$(date +%s)
        uptime_seconds=$((current_timestamp - boot_timestamp))
        printf "%.2f\n" $(echo "$uptime_seconds / 3600" | bc -l)
    else
        printf $(awk '{printf "%.2f\n", $1/3600}' /proc/uptime)
    fi
}

# Display oh-my-zsh version
function omzversion() {
    printf "${green}oh-my-zsh ${yellow}$(omz version)$reset is installed in ${purple}$ZSH${reset}\n"
}

function minimize-login-info() {
    if [[ "$(osname)" == "ubuntu" ]]; then
        sudo chmod -x /etc/update-motd.d/00-header
        sudo chmod -x /etc/update-motd.d/10-help-text
        sudo chmod -x /etc/update-motd.d/50-motd-news
        #sudo chmod -x /etc/update-motd.d/90-updates-available
        sudo chmod -x /etc/update-motd.d/91-contract-ua-esm-status
    elif [[ "$(osname)" == "debian" ]]; then
        #sudo chmod -x /etc/update-motd.d/10-uname
        sudo cp /etc/motd /etc/motd.org
        sudo rm -f /etc/motd
        sudo touch /etc/motd
    fi
    if [[ ! "$(osname)" == "macos" ]]; then
        sudo ln -sf ~/GitHub/config/motd/05-header /etc/update-motd.d
    fi
}


export ZSH_FUNCTIONS_LOADED=1
