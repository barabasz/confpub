#!/bin/zsh

# track loaded files
# local thispath="${(%):-%x}"
zsh_files+=("zsh_functions")

# apt unattended quiet install
function aptinstall() {
    [[ $(isinstalled needrestart) -eq 1 ]] && needrestart-quiet
    export NEEDRESTART_MODE=a 
    export DEBIAN_FRONTEND=noninteractive
    aptopt='-qq'
    grpopt='-Eiv'
    filter='^needrestart|^update|^reading|^building|^scanning|^\(|^\s*$'
    sudo apt-get install $aptopt $@ | grep $grpopt $filter
    [[ $(isinstalled needrestart) -eq 1 ]] && needrestart-verbose
}

# Source file if exists
function sourceif() {
    [[ $# -eq 0 ]] && echo "Usage: sourceif <file> [error message]" && return 1
    if [[ $# -eq 1 ]]; then
        script="${redi}sourceif error${reset}"
    else
        script="${redi}sourceif error${reset} in ${yellow}$2${reset}"
    fi

    if [[ -f $1 ]]; then
        source $1
    else
        [[ $# -ge 2 ]] && printf "$1 not found\n" || printf "$2: $1 not found\n"
        printf "$script: ${cyan}$1${reset} not found\n"
        return 1
    fi
}

# Execute external script
function extscript() {
    /bin/bash -c "$(curl -fsSL $1)"
}

# Source external file
function extsource() {
    source /dev/stdin <<< "$(curl -fsSL $1)"
}

# Get shell name
function get_shell() {
    echo $SHELL | xargs basename
}

function command_exists() {
   type "$1" &>/dev/null
}

# Check if programm is installed
function isinstalled() {
    if [[ $(utype $1) == 'file' || "$(uwhich $1)" == /* ]]; then
        echo 1
    else
        echo 0
    fi
}

# Check if package is installed by Brew
function isinstalledbybrew() {
    brew list $1 &>/dev/null
    if [ $? -eq 0 ]; then
        echo 1
    else
        echo 1
    fi
}

# Better ln command for creating symbolic links
function lns() {
    
    # function properties
    local fargs="<destination> <source>"
    local minargs=2
    local maxargs=2
    
    # argument check
    local thisf="lns"
    local error="${redi}$thisf error:${reset}"
    local info="${green}$thisf info:${reset}"
    local usage=$(usage $thisf $fargs)
    [[ $# -eq 0 ]] && printf "$usage\n" && return 1
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && printf "$error $args\n$usage\n" && return 1

    #main
    local dst="$1"
    local src="$2"
    local dst_c="${cyan}$dst${reset}"
    local src_c="${cyan}$src${reset}"
    local src_dir="$(dirname "$src")"
    local src_dir_c="${cyan}$src_dir${reset}"
    local arr="${yellowi}â†’${reset}"
    local errors=0

    # Check if both the destination and source are provided as absolute paths.
    if [[ "$dst" != /* ]]; then
        printf "${error} the destination $dst_c must be an absolute path.\n"
        ((errors+=1))
    fi
    if [[ "$src" != /* ]]; then
        printf "${error} the source $src_c must be an absolute path.\n"
        ((errors+=1))
    fi

    # Check if the destination is different from the source
    if [[ "$dst" == "$src" ]]; then
        printf "${error} destination and source cannot be the same.\n"
        ((errors+=1))
    fi

    # Check if the destination exists
    if [[ ! -e "$dst" ]]; then
        printf "${error} destination $dst_c does not exist.\n"
        ((errors+=1))
    fi

    # Check if the destination is readable
    if [[ ! -r "$dst" ]]; then
        printf "${error} destination $dst_c is not readable.\n"
        ((errors+=1))
    fi

    # Check if the destination is a folder or file
    if [[ ! -d "$dst" ]] && [[ ! -f "$dst" ]]; then
        printf "${error} destination $dst_c is neither a directory nor a file.\n"
        ((errors+=1))
    fi

    # Check if the current process can write to the source's folder
    if [[ ! -w "$src_dir" ]]; then
        printf "${error} cannot write to the source's folder $src_dir_c\n"
        ((errors+=1))
    fi

    # Exit if there are errors
    if [[ $errors > 0 ]]; then
        return 1
    fi
    
    # Check if exactly such a symbolic link does not already exist
    if [[ -L "$src" ]] && [[ "$(readlink "$src")" == "$dst" ]]; then
        printf "${info} symbolic link $src_c $arr $dst_c already exists.\n"
        return 0
    fi

    # Remove the existing source (file, folder, or wrong symbolic link)
    if [[ -e "$src" ]]; then
        rm -rf "$src"
        if [[ $? -ne 0 ]]; then
            printf "${error} failed while rmoving $src_c (error rissed by rm).\n"
            return 1
        else
             printf "${info} removed existing source $src_c.\n"
        fi
    fi

    # Create the symbolic link
    ln -s "$dst" "$src"
    if [[ $? != 0 ]]; then
        printf "${error} failed to create symbolic link (error rissed by ln).\n"
        return 1
    else
        printf "${info} created symbolic link: $src_c $arr $dst_c\n"
        return 0
    fi

}

# Create dir and enter it
function mdcd() {
    mkdir -p $1 && cd $_
}

# Display OS name
function osname() {
    local ostype=$(uname -s | tr '[:upper:]' '[:lower:]')
    if [[ $ostype == 'darwin' ]]; then
        printf "macos"
    elif [[ $ostype == 'linux' ]]; then
        if [[ -f /etc/os-release ]]; then
            # awk -F= '/^ID=/{print $2}' /etc/os-release
            local id=$(cat /etc/os-release | grep "^ID=")
            printf "${id#*=}"
        fi
    else
        printf "unknown"
    fi
}

# modify /etc/needrestart/needrestart.conf
# use: needrestart-mod parameter value
if [[ "$(osname)" != "macos" ]]; then
    function needrestart-mod() {
        filename=/etc/needrestart/needrestart.conf
        sudo sed -i "s/^#\?\s\?\$nrconf{$1}.*/\$nrconf{$1} = $2;/" $filename
    }
    function needrestart-quiet() {
        needrestart-mod verbosity 0
        needrestart-mod systemctl_combine 0
        needrestart-mod kernelhints 0
        needrestart-mod ucodehints 0
    }
    function needrestart-verbose() {
        needrestart-mod verbosity 1
        needrestart-mod systemctl_combine 1
        needrestart-mod kernelhints 1
        needrestart-mod ucodehints 1
    }
fi

# Search man with fzf
function fman() {
    man -k . | fzf -q "$1" --prompt='man> '  --preview $'echo {} | tr -d \'()\' | awk \'{printf "%s ", $2} {print $1}\' | xargs -r man | col -bx | bat -l man -p --color always' | tr -d '()' | awk '{printf "%s ", $2} {print $1}' | xargs -r man
}

# Extract version number from string
function getver_old() {
    local verstr=$1
    verstr=$(echo $verstr | sed 's/^[^0-9]*//')
    verstr=$(echo $verstr | grep -oE '[0-9]+(\.[0-9]+)*' | head -1)
    echo $verstr
}

function getver() {
    local verstr=$1
    verstr=$(echo "$verstr" | sed 's/^[^0-9]*//')
    verstr=$(echo "$verstr" | grep -oE '[0-9]+(\.[0-9]+)*' | head -1)
    echo "$verstr"
}

# Get shell version
function shellver() {
    if [[ $(shellname) == 'zsh' ]]; then
        local version=$(zsh --version)
    elif [[ $(shellname) == 'bash' ]]; then
        local version=$(bash --version)
        version="${version#*version }"
    else
        echo "extractver: unknown shell"
        return 1
    fi
    echo $(getver $version)
}

# Get shell name
function shellname() {
    case "$(ps -p $$ -o comm=)" in
        *zsh)
            echo "zsh"
            ;;
        *bash)
            echo "bash"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Information about function parameters
function params() {
    echo "Number of parameters: $#"
    echo "Parameters: $@"
    echo "First parameter: $1"
    echo "Second parameter: $2"
    echo "Last parameter: ${@: -1}"
}

# Check number of parameters
function checkargs() {
    if [[ $# -ne 3 ]]; then
        printf "${redi}checkargs error${reset}: not enough arguments (expected 3, given $#)\n"
        printf "checkargs usage: ${yellow}checkargs${reset} ${green}<min> <max> <actual>${reset}\n"
        return 1
    fi

    local min=$1
    local max=$2
    local given=$3
    local msg1=""; local msg2=""

    if [[ $min -gt $max ]]; then
        echo "checkargs: min number of arguments cannot be greater than max"
        return 1
    elif [[ $given -lt 0 ]]; then
        echo "checkargs: actual number of arguments cannot be negative"
        return 1
    fi

    if [[ $given -eq 0 ]]; then
        msg1="no arguments given"
    elif [[ $given -lt $min ]]; then
        msg1="not enough arguments"
    elif [[ $given -gt $max ]]; then
        msg1="too many arguments"
    fi

    if [[ $given -lt $min || $given -gt $max ]]; then
        if [[ $1 == $2 ]]; then
            msg2="expected $min"
        else
            msg2="expected $min to $max"
        fi
        echo "$msg1 ($msg2, given $given)"
        return 1
    fi

    echo "ok"
    return 0
}

# Usage message for functions
function usage() {
    local fname=$1
    local fargs=$2
    printf "$1 usage: ${yellow}$1${reset} ${green}$2${reset}\n"
}

# Universal better type command for bash and zsh
# returns: 'file', 'alias', 'function', 'keyword', 'builtin' or 'not found'
function utype() {
    # function properties
    local fargs="<command>"
    local minargs=0
    local maxargs=1
    # argument check
    local thisf="${funcstack[1]}"
    local error="${redi}$thisf error:${reset}"
    local usage=$(usage $thisf $fargs)
    [[ $# -eq 0 ]] && printf "$usage\n" && return 1
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && printf "$error $args\n$usage\n" && return 1

    if [[ $(shellname) == 'bash' ]]; then
        output=$(type -t $1)
        if [[ -z $output ]]; then
            echo "not found"
            return 1
        fi
    elif [[ $(shellname) == 'zsh' ]]; then
        tp=$(type $1)
        if [[ $(echo $tp | \grep -o 'not found') ]]; then
            echo "not found"
            return 1
        elif [[ $(echo $tp | \grep -o 'is /') ]]; then
            output='file'
        elif [[ $(echo $tp | \grep -o 'alias') ]]; then
            output='alias'
        elif [[ $(echo $tp | \grep -o 'shell function') ]]; then
            output='function'
        elif [[ $(echo $tp | \grep -o 'reserved') ]]; then
            output='keyword'
        elif [[ $(echo $tp | \grep -o 'builtin') ]]; then
            output='builtin'
        fi
    else
        echo "utype: unsupported shell"
        return 1
    fi

    echo $output
}

# Universal better which command for bash and zsh
function uwhich() {
    # function properties
    local fargs="<command>"
    local minargs=0
    local maxargs=1
    # argument check
    local thisf="${funcstack[1]}"
    local error="${redi}$thisf error:${reset}"
    local usage=$(usage $thisf $fargs)
    [[ $# -eq 0 ]] && printf "$usage\n" && return 1
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && printf "$error $args\n$usage\n" && return 1

    local type=$(utype $1)
    if [[ $type == "file" ]]; then
        echo $(which $1)
    elif [[ $type == "alias" ]]; then
        if [[ $(shellname) = "zsh" ]]; then
            echo $(whence -p $1)
        else
            echo $(which $1)
        fi
    elif [[ $type == "not found" ]]; then
        echo "${yellow}$1${reset} $type"
        return 1
    else
        echo "${yellow}$1${reset} is a ${green}$type${reset}"
        return 1
    fi
}

# Short version info, usage: verinfo cliname appname versioncommand
# Example: verinfo gzip "GNU Zip" --version
function verinfo() {
    # function properties
    local fargs="<cliname> [appname] [versioncommand]"
    local minargs=0
    local maxargs=3
    # argument check
    local thisf="${funcstack[1]}"
    local error="${redi}$thisf error:${reset}"
    local usage=$(usage $thisf $fargs)
    [[ $# -eq 0 ]] && printf "$usage\n" && return 1
    local args=$(checkargs $minargs $maxargs $#)
    [[ $args != "ok" ]] && printf "$error $args\n$usage\n" && return 1

    if [[ -z "$2" ]]; then
        cliname=$1; appname=$1; vercmmd="--version"
    elif [[ -z "$3" ]]; then
        cliname=$1; appname=$2; vercmmd="--version"
    else
        cliname=$1; appname=$2; vercmmd=$3
    fi

    local type=$(utype $cliname)
    if [[ $type == "not found" ]]; then
        printf "$yellow$cliname$reset not found\n"
        return 1
    fi

    if [[ "$(uwhich $cliname)" == /* ]]; then
        msg='is installed in'
        apppath="$(uwhich $cliname)"
        verstr="$($apppath $vercmmd 2>&1)"
        ver=$(getver "$verstr")
        printf "${green}$appname${reset} ${yellow}${ver}${reset} $msg ${cyan}$apppath${reset}\n"
    fi
    if [[ $type = 'alias' ]]; then
        msg='is an alias for'
        als="${green}$cliname${reset} $msg ${purple}$(alias $cliname | sed "s/.*=//")${reset}"
        echo -e "$als"
    fi
    if [[ $type = 'function' || $type = 'keyword' || $type = 'builtin' ]]; then
        msg='is a'
        als="${green}$cliname${reset} $msg ${purple}$type${reset}"
        echo -e "$als"
    fi    
}

function makeconfln() {
    local source=$GHCONFDIR/$1
    local target=$CONFDIR/$1
    local source_c="${cyan}$source${reset}"
    local target_c="${cyan}$target${reset}"
    local arrow="${yellow}â†’${reset}"
    if [[ -L $target ]] && [[ "$(readlink $target)" = "$source" ]]; then
        echo "symlink $target_c $arrow $source_c exists"
    else
        if [[ -a $target ]]; then
            if [[ -d $target ]]; then
                echo "removing folder $target_c"
            else
                echo "removing file $target_c"
            fi
            rm -r $target
        fi
        ln -sfF $source $target
        echo "symlink $target_c $arrow $source_c created"
    fi
}

function dlunzip() {
    if [ $# -ne 2 ]; then
        echo "dlunzip (download and extract)"
        echo "Usage: dlunzip <url> <folder>"
        return 1
    fi

    url="$1"
    folder="$2"

    [[ ! $folder == /* ]] && folder="$(pwd)/$folder"
    [[ -z "$TEMP" ]] && tempdir="$HOME/.temp" || tempdir="$DLDIR"
    filename=$(basename "$url")
    tempfile="$tempdir/$filename"
    extdir="${folder}/$(basename $filename .zip)"

    mkdir -p "$folder"
    mkdir -p "$tempdir" && cd $_

    wget -q $url
    if [ $? -ne 0 ]; then
        echo "Failed to download $url"
        return 1
    fi

    unzip -q $tempfile -d $folder
    if [ $? -ne 0 ]; then
        echo "Failed to extract $tempfile to $folder"
        return 1
    fi

    rm $tempfile

    echo $extdir
}

function loginfiles() {
    printf "Login files: "
    if [[ -z $zsh_files ]]; then
        printf "${redi}error${reset}: zsh_files not found"
        return
    else
        i=1; l=${#zsh_files[@]}
        for file in $zsh_files; do
            f=$(basename $file)
            printf "${cyan}${f#.}${reset}"
            [[ i -lt l ]] && printf " ${yellow}â†’${reset} "
            ((i++))
        done
    fi
    printf "\n"
}

function logininfo() {
    local user=$(whoami)
    local userc=$yellow$user$reset
    local host=$(hostname -s)
    local domain=$(hostname -d)
    [[ -n $domain ]] && host="$host.$domain"
    local hostc=$cyan$host$reset
    local tty=$(tty | sed 's|/dev/||')
    local ttyc="$green$tty$reset"
    local remote=$(who | grep $tty | grep -oE '\([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+\)' | tr -d '()')
    [[ -n $remote ]] && local remotec="from $cyan$remote$reset"
    if [[ $(isinstalled ifconfig) -eq 1 ]]; then
        local ip=$green$(ifconfig | awk '/inet / && !/127.0.0.1/ {print $2}')$reset
    else
        local ip=$(ip addr show | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | cut -d'/' -f1)
    fi
    local ipc=$green$ip$reset
    printf "Logged in as $userc@$hostc ($ipc) on $ttyc $remotec\n"
}

function sysupdate() {
    if [[ ! "$(osname)" == "macos" ]]; then
        envopt="NEEDRESTART_MODE=a DEBIAN_FRONTEND=noninteractive"
        aptopt="-qq"
        filter1='^Hit|^Get'
        filter2='^NEEDRESTART|^update|Reading'

        sudo apt-get update | grep -Ev $filter1
        sudo $envopt apt-get $aptopt upgrade | grep -Ev $filter2
        sudo $envopt apt-get $aptopt dist-upgrade

        sudo apt-get $aptopt clean
        sudo apt-get $aptopt autoclean
        sudo apt-get $aptopt autoremove
        sudo sync
    fi

    if [[ $(isinstalled brew) -eq 1 ]]; then
        brew update --auto-update
        brew upgrade
        brew cleanup
    fi
}

# Calculate uptime in hours
function uptimeh() {
    if [[ $(osname) == "macos" ]]; then
        boot_timestamp=$(sysctl -n kern.boottime | awk '{print $4}' | tr -d ',')
        current_timestamp=$(date +%s)
        uptime_seconds=$((current_timestamp - boot_timestamp))
        printf "%.2f\n" $(echo "$uptime_seconds / 3600" | bc -l)
    else
        printf $(awk '{printf "%.2f\n", $1/3600}' /proc/uptime)
    fi
}

# Display macOS codename
function macosname() {
    local version=$(sw_vers -productVersion)
    local major=$(echo $version | cut -d. -f1)
    case $major in
        15) printf "Seqouia" ;;
        14) printf "Sonoma" ;;
        13) printf "Ventura" ;;
        12) printf "Monterey" ;;
        11) printf "Big Sur" ;;
        *)  printf "Unknown" ;;
    esac
}

# Display system info
function sysinfo() {
    local os_kernel=$(uname -r)
    local os_shell=$(shellname)
    local os_shell_ver=$(shellver)
    local os_arch=$(uname -m)
    local os_uptime=$(uptimeh)

    if [[ $(osname) == "macos" ]]; then
        local os_name="macOS"
        local os_version=$(sw_vers -productVersion)
        local os_codename=$(macosname)
    else
        local os_name=$(awk -F= '/^NAME=/{gsub(/^"|"$/, "", $2); print $2}' /etc/os-release)
        local os_version=$(awk -F= '/^VERSION_ID=/{gsub(/^"|"$/, "", $2); print $2}' /etc/os-release)
        local os_codename=$(awk -F= '/^VERSION_CODENAME=/{gsub(/^"|"$/, "", $2); print $2}' /etc/os-release)
    fi
    printf "This is ${yellowi}$os_name${reset} $os_version (${(C)os_codename}) with ${yellow}$os_shell${reset} $os_shell_ver running on ${yellow}$os_arch${reset} for $os_uptime hrs\n"
}

# oh-my-zsh functions

function isomzinstalled() {
    if [[ -d $ZSH ]] && [[ $(omz version | grep -o 'master' | head -1) = 'master' ]];
    then echo 1; else echo 0; fi
}

function installomzplugin() {
    local repo=https://github.com/zsh-users/$1.git
    local pdir=$ZSH_CUSTOM/plugins/$1
    printhead "Installing $1"
    [[ -d $pdir ]] && rm -rf $pdir
    git clone $repo $pdir
}

function omzversion() {
    printf "${green}oh-my-zsh ${yellow}$(omz version)$reset is installed in ${purple}$ZSH${reset}\n"
}

function minimize-login-info() {
    if [[ "$(osname)" == "ubuntu" ]]; then
        sudo chmod -x /etc/update-motd.d/00-header
        sudo chmod -x /etc/update-motd.d/10-help-text
        sudo chmod -x /etc/update-motd.d/50-motd-news
        #sudo chmod -x /etc/update-motd.d/90-updates-available
        sudo chmod -x /etc/update-motd.d/91-contract-ua-esm-status
    elif [[ "$(osname)" == "debian" ]]; then
        #sudo chmod -x /etc/update-motd.d/10-uname
        sudo cp /etc/motd /etc/motd.org
        sudo rm -f /etc/motd
        sudo touch /etc/motd
    fi
    if [[ ! "$(osname)" == "macos" ]]; then
        sudo ln -sf ~/GitHub/config/motd/05-header /etc/update-motd.d
    fi
}

export ZSH_FUNCTIONS_LOADED=1
